{"id":"2016-08-26-tdd-series-2-why-and-when-using-tdd","title":"TDD的迷思（二）：意义篇","contents":"\n\n> 本文仅在Java上下文下讨论TDD。原因是Java具备适合TDD生存的一些语言特性：清晰的依赖引用import机制、完全的面向对象、不存在引用传递等。迁移讨论至其他语言上时请注意这些特性对TDD实践所带来的差异。\n\n## 背景：银弹还是鸡肋\n\nTDD还是不TDD，这是在ThoughtWorks工作绕不过去的一个问题~~怎么总觉得[这帽子扣得没熊节好](http://www.infoq.com/cn/articles/enterprise-systems-integration-points)[^summarize]~~。TDD是一种思维方式，它把测试带到了与开发同等的地位上来。如果想要让你的代码边界清晰，有序可控，自成模块文档，那么你必须写清晰易懂的测试，你必须知道单元测试如何覆盖产品代码。若果如其然，是不是每个ThoughtWorker都认同TDD，并自觉在项目上使用TDD？若并非每个人都做到，原因又是什么，是因为TDD确实也有它不适合的场景，或一言以蔽之，是因为人员TDD技巧与素养皆太菜？\n\n第一个问题的答案是否定的。是不是每个ThoughtWorker都认同TDD这个我不清楚，因为我是认同的，而其他人我则懒于主动求证是否认同，故此命题无法证假；但后半句答案是否定的，至少我就不是，我自觉，但并非所有时刻都用；昨天和我聊TDD的澳洲ThoughtWorker阿蒙萌也是看情况用。我们2票便否定了“每个”这全称量词。那么，既然至少有2人在项目没有坚持使用TDD，（他们的）原因又是什么？阿蒙萌曰：\n\n> It depends. \n\n言下之意，TDD有时好用，有时难用。且就这个论断继续讨论下去，那么TDD什么场景下好用，什么场景下难用呢？那些难用的场景，是人员主观上技巧素养太弱而产生的误解呢，还是客观上真实存在的障碍呢？\n\n### TDD适用场景\n\n* 输入输出非常清晰时（clear input/output）\n* 项目代码采用良好的MV*(MVP/MVC/MVVM)架构时（well MVP/MVC/MVVM designed）\n\n### TDD不适用场景\n\n* 使用全局变量在方法间传递、保存值（shared global variable across methods in class）\n* 有副作用的方法（side-effect methods）\n* 无返回值的方法（void methods）\n* 逻辑层和视图层间耦合严重（logic deeply coupled with the view）\n\n### 函数式的代码风格\n\n适用第一点与不适用的第一二点其实是一个意思，即接近于[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)的代码风格：**清晰的输入输出**、**无副作用**、**引用透明（Referential Transparency）**。毕竟，没有输入输出，就没有测试用例。遵循测试驱动开发写出来的代码可能是这样的：\n\n```java\n@Test \npublic void should_give_80_percent_discount_when_customer_buying_over_3_apples() throws Exception {\n\tdouble amount = customer.buy(4, apples.withEach$(5.00));\n\t\n\tassertThat(amount, is(4 * 5.00 * 0.8));\n}\n```\n\n### 外部依赖\n\n不适用的第三点：没有返回值的方法。方法没有返回值，有以下几种可能的情况：\n\n* 使用了全局变量，或修改或存储了应用的状态以供他用。这其实就是违反“函数式代码风格”的理念，见上讨论\n* 使用了输出参数。通常是在传入参数是个类型引用，然后在方法体内往传入参数中写值，从而达到方法返回值的效果\n* 调用了三方服务。比如进行了数据库操作、网络连接、文件读写等一切形式的I/O（非内存）操作\n\n首先我想表达的观点是，按照TDD进行的设计，很少会出现这种自己也测试不了的代码。但既然软件工程是人的行为，坏代码总会出现，那么以上面两点可能为例，这是无法解决的客观因素，还是可以解决的呢？可以解决。如果方法中使用了输出参数，那么可考虑是否将代码重构成正常的返回值方法；如果方法中调用了三方服务，那么测试策略可以从 **验证返回值** 的思路转换为 **验证特定行为确实正确发生**，这与第一篇技巧篇中提到的依赖注入技术和mock对象即可实现。\n\n但不可否认，上面的“重构”这个字眼，意味着我们在TDD时，可能会有额外的投入，如额外添加测试保障、重构旧有代码等。这个问题，已不能从单纯技术层面进行解决，但后面我会聊。\n\n### MV*架构——核心业务逻辑与模型/视图的解耦\n\n适用和不适用场景的最后一条，都提到了MV*架构对于TDD有所裨益。原因何在？因为有了清晰的分层，大部分主要的业务逻辑将由C（Controller，控制器）或VM（View Model）来负责。通过将领域模型和展示视图隔离出去，我们得以厘清业务层的输入输出。这回到了我们所聊到的第一点情况：函数式风格的输入输出。\n\n不难发现，那些我们提到“TDD不一定适用”的场景，无论是因为代码上使用了难以测试的全局变量/输出参数，还是因为架构上业务逻辑与视图展示逻辑强耦合引起的测试黑洞，归根结底都指向了一个问题：取决于代码库设计/实现的好坏。好的代码容易TDD，自然维持更好；坏的代码TDD寸步难行，后来者更倾向于copy/paste重复代码，自然质量每况愈下。因此，看人品，如果你人品好，工作在优雅的codebase上，那就能TDD，否则就不能。\n\n聊到这里似乎是把开发者的责任撇得干干净净：这是代码库的责任，而与开发者自身的TDD技艺、素养等无关。但我们不能止步于此，且不论好代码是如何得来，也暂且不论什么架构腐化演进的问题~~因为我现在也聊不来…~~，这里有一个问题Developer有责任思考及行动：**重构（大型）遗留项目是否有价值？若是，如何对（大型）遗留项目进行重构？**\n\n## 大型遗留项目的重构与TDD\n\n我们从TDD一路聊到大型遗留项目的重构，似乎是跑了题。这里为何强调大型？因为小型的重构和TDD可以在短时间（2~3天内的体量）完成，它们可以作为需求的一部分同时被交付，不涉及系统级的重构。一加大型，我们就需要意识到：其所需投入的时间和人力，已大至需要作为项目范围的一部分被规划和交付。那么，首要的问题即是，这样大型的系统重构，是否有意义？其价值何在？\n\n### 重构大型遗留项目的价值\n\n要探讨价值，就要知道价值是什么，它需在一个系统和业务的上下文中展开。\n\n---\n\n[^summarize]: “集成是企业应用系统中绕不开的话题”。首句即把帽子扣下，这是绕不开的，所以我才来聊聊。真假不论，先装腔作势一番。\n"}