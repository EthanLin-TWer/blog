---
title: 读《架构整洁之道》
category: 读书笔记
---

架构整洁之道，实乃省钱之道。**省钱**，是读懂本书的一个核心视角。专业人士的价值，不仅在于交付满足当下需求、乃至未来变化的软件，更在于他们能够采用**效率最高、成本最低**的软件架构完成此事。这本书就是写给预备承担、或者正在承担架构责任的资深工程师们。

本篇中，我不仅会分享我觉得本书精要的内容，更主要的是我会分享我的读书方法。读书的顺序，有时跟目录顺序并不是完全一致的，如何按照自己的方式抓住全书脉络并安排阅读顺序，是我觉得也很有趣、值得分享出来互相交流的一部分。我一直认为，内容与形式是统一的，形式正是内容的一部分。不注意表达的形式，就难以真正了解被表达的内容。

## 目录

* [全书结构](#全书结构)
* [什么是软件架构](#什么是软件架构)
* [什么是组件](#什么是组件)
* [软件架构的研究内容](#软件架构的研究内容)
  * [如何划分组件：聚合与耦合](#如何划分组件：聚合与耦合)
  * [如何管理依赖关系](#如何管理依赖关系)
  * [如何管理边界/通信方式](#如何管理边界/通信方式)
* [软件架构的案例及分析](#软件架构的案例及分析)
* [参考](#参考)

## 全书结构

全书共34章，其中原书第2-5部分（第3-29章）占比最多达79%，是全书的主要部分。第1部分开宗明义，讲清了软件的架构价值是什么，为本书所讨论的话题定下框架；第2、3、4部分由浅入深，从低层到高层依次探讨了软件架构的构成元素：编程范式、设计原则和组件。第5部分开始，以组件为基本元素展开对软件架构的讨论；第6部分软件架构核心以外的实现细节。

本书的主题是**软件架构**，而组成架构的基本元素是**组件**，因此阅读本书的**第一个关键，首先是弄清这“软件架构”及“组件”这两个词的内涵**，它们相关的章节（第1-2、15章讲架构，第12章讲组件）是本书的核心，为了弄清楚我甚至翻阅了原文。基于清晰的组件定义，我们得以进一步讨论软件架构，它涉及对系统进行组件划分（第13-14章）、管理组件之间在编译期的依赖关系（第16-18章、第24章）以及运行时的边界/通信方式（第19章）。最后，作者在22章给出了这样一个符合所有原则的“整洁架构”，并在第6部分的末尾给出了两个分析实例（第33-34章）。

所以本书的阅读脉络是这样：

1. 什么是**系统架构**（第1-2章、第15章）
2. 什么是构成架构基本要素的**组件**（第12章、第13-14章）
3. 软件架构研究的核心内容（第16-19章、第24章）
4. 软件架构案例、设计思路与分析（第22章、第33-34章）

其他的部分，固然不乏精彩的洞见（比如面向对象的本质是基于多态能力对源码级依赖进行管控的架构意义上的能力、SRP中指出系统的行为者actor是导致软件修改的原因，等），但我的读书过程仅集中在“软件架构”和“组件”这两条主线上，因而我会弱化这些部分的讨论、留给读者自行阅读。这些被弱化的章节包括：第2-3部分（编程范式、设计原则）、第5部分部分章节（第20-21、22-23、25-26、28-29章，读者可按需阅读）以及第6部分的部分实现细节章节（第30-32章，一句话可以说完：数据库、UI、框架都应该依赖于业务逻辑组件作为其插件，以免污染核心架构）。

## 什么是软件架构

这是本书第1部分探讨的问题。

> 软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。 —— P5
> 软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本。 —— P122

看看，什么叫做专业~~省钱~~。专业人士对于其雇主和他人的最大价值，不仅在于他能使软件具备长时间内响应业务需求的能力（系统的行为价值），而且在于他能用最低的成本来完成这件事（系统的架构价值）。这包括内置的高质量、各种自动化部署、减少软件过程各种不必要的架构浪费等，一言以蔽之，软件架构是一件专业的、精益的工作，它应该交由专业人士来完成。

这里作者又敏锐地指出，这个做架构的专业人士（可以称之为架构师），仅仅是一个角色（通常是编码最优秀的那个工程师承担），而不是一个脱离编码一线的、隔离的“岗位”。那些认为“架构”属于“高层级”工作，而“编码/设计”属于“低层级”的实现型细节型工作，“架构师”的工作就是发号施令指挥“（可替换的）程序员”去干活的想法，本身就是不专业的、错误的（如果不是坏的）。不涉及实现细节的架构工作是不存在的。架构设计必须由奋斗在一线的、经常接触细节的、最有想法的、有经验的、更加资深的、富有责任感的工程师来担当，连代码都不写/写不好的大佛爷们可以走开了，斗争的就是你。

**减少成本**（各种不是必要的成本），这是看待软件架构一切元素的根本出发点，也是更好使用本书的一个视角。

那么具体来说，有哪些方面的成本可以减少呢？达成此目标的策略是什么呢？策略之下有哪些具体的办法/手段可以达成“最小化成本”这个目标呢？作者在第5部分“软件架构”的开篇——第15章——详细地回答了这几个问题，可谓是纲举目张。这部分总纲，之所以没放到第1部分来，我认为是因为软件架构的基本元素涉及一个“组件”的概念，而为了讲解组件这个概念，作者又花了3个部分、12个章节、超过三分之一~~specifically, 12/34≈35%>33%，我是很严谨的~~的篇幅来铺垫，所以不得不把15章放到第5部分去。但是作为读者，我们完全可以暂时把“组件”的具体概念束之高阁，来看看15章关于**软件架构**的总纲。

15章集中指出：

**软件架构的终极目标及评价标准**，是最大化程序员的生产力，同时最小化系统的总运营成本。

**软件架构的主要目标**，是为了支撑软件系统的全生命周期，减少软件过程中（对组成系统架构的各个组件的）研发、运行、部署、维护等方面的成本。

**软件架构的主要策略**——也即实现该主要目标的策略——是在设计中尽可能长时间地保留尽可能多的可选项。

**软件架构的实现办法**——也即其研究对象/工作内容——涉及规划如何将系统合理切分成为组件（第12-14章）、安排好组件之间在编译期/源码级别的依赖关系（第19章），以及设计组件之间在运行时的边界和通信方式（第16-18章）。

弄清楚软件架构的根本目标、方法论及研究对象，本书的主要内容和结构就无比清晰地呈现在了我们面前。接下来，我们需要研究本书第二个关键的概念，也就是软件架构的主要研究对象——组件。

## 什么是组件

[中文版译本中对“组件”的定义与原意有些出入][架构整洁之道导读（二）续]，这个时候我们可以直接去阅读原文。我把[O'Reilly上原书对组件定义的前两段][12 - Components]摘录如下并做了强调：

> **Components are the units of deployment. They are the smallest entities that can be deployed as part of a system**. In Java, they are jar files. In Ruby, they are gem files. In .Net, they are DLLs. In compiled languages, they are aggregations of binary files. In interpreted languages, they are aggregations of source files. In all languages, they are the granule of deployment.
> 
> Components can be linked together into a single executable. Or they can be aggregated together into a single archive, such as a .war file. Or they can be independently deployed as separate dynamically loaded plugins, such as .jar or .dll or .exe files. **Regardless of how they are eventually deployed, well-designed components always retain the ability to be independently deployable** and, therefore, independently developable.

这两段指出了作者对“组件”的定义，具备**物理级别的部署单元**和**源码级别的逻辑单元**两个层次。建立这个区分极其重要，它将直接影响你阅读后续章节的流畅性，在全书的行文中作者提到的“组件”有时主要指物理意义上的“部署单元”（比如13-14章讨论组件聚合和耦合时），有时又主要指源码意义上的“逻辑单元”（比如第22章P183页的图22.2显然不能理解为应用的每个分层都是物理意义上的部署单元，我曾经一度陷入混乱和自我怀疑之中）。

组件作为物理意义上的部署单元，这层含义应该很明确，因为作者说“组件是软件的部署单元，是可以作为系统的一部分被部署的最小实体”。那么部署单元又是指什么？这两段举例了，对于编译型语言来说，它可以是一组二进制文件的集合（比如.jar文件、DLL文件等）；对于解释型语言来说，它直接就是一组源代码文件的集合。通读12章后续“组件发展史”等几小节后，你会发现作者所说的部署单元，就是指经过“编译”（compile）、“链接”（link）等阶段（解释型语言可能不存在这些阶段）之后得到的产物：一个可以被加载器（loader）直接加载（load）并执行（execute）的文件。我的理解，说白了，**组件就是一个可执行文件**。它是一个部署概念。

再来看组件作为源码意义上的逻辑单元这层含义。原文讲，“不管组件**最终**被如何部署（采用何种部署形式），设计良好的组件应该始终保有可被独立部署的能力”。也即是说，哪怕是一个尚未成为物理形式的可独立部署单元、但在设计随时保有这种可能性的组件——也就是源码级别的一组文件集合——仍然可以称为组件。这肯定了组件在作为部署单元的物理意义之外的另一种可能形式，也即仅仅存在于源代码级别的逻辑单元。这是一个逻辑概念。

由此，我们明白了，作者对组件具备两个层次的定义：其主要定义是物理意义上的部署单元，此外还有尚未成为物理部署单元、但随时保有此种向物理部署转化能力的、源码意义上的逻辑单元。

<more questions going on...>

## 软件架构的研究内容

### 如何划分组件：聚合与耦合

### 如何管理依赖关系

### 如何管理边界/通信方式

## 软件架构的案例及分析

## 参考

[架构整洁之道导读（二）续]: https://www.jianshu.com/p/fdb8c8a604b1
[12 - Components]: https://www.oreilly.com/library/view/clean-architecture-a/9780134494272/ch12.xhtml#ch12
